### 트리 (Tree)

- 트리는 계층적인 구조를 표현: 조직도, 디렉토리와 서브디렉토리 구조, 가계도

- 트리는 node들과 node들을 연결하는 link들로 구성됨
  맨 위의 노드를 root라고 부름

- 부모-자식 관계
  부모가 동일한 노드들을 형제 관계라고 부름
  루트노드를 제외한 트리의 모든 노드들은 유일한 부모 노드를 가짐

- leaf node
  자식이 없는 노드들을 leaf 노드라고 부름
  leaf 노드가 아닌 노드들을 내부노드라고 부름

- 조상-자손 관계
  부모-자식 관계를 확장한 것

- subtree(부트리)
  트리에서 어떤 한 노드와 그 노드의 자손들로 이루어진 트리

- level
  root는 level1, root의 자식들은 level2, 손자들은 level3

- height
  level1, 2, 3 -> 높이는 3  
<br/>


**트리의 기본적인 성질**

노드가 n개인 트리는 항상 n-1개의 link를 가짐
루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일하다.
(같은 노드를 두 번 이상 방문하지 않는다는 조건하에)

<br/><br/>



### 이진 트리 (Binary Tree)

- 각 노드는 최대 2개의 자식을 가짐
- 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정됨
  (자식이 한 명인 경우에도)
<br/>


**Full and Complete Binary trees**

- full binary tree: 모든 레벨에서 노드들이 꽉 차있는 트리
- complete binary tree: 맨 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차있어야 함
  맨 마지막 레벨에서는 오른쪽에서부터 연속된 몇개의 노드만 빌 수 있음
- 높이가 h인 full binary tree는 2^h - 1개의 노드를 가짐
- 노드가 n개인 full혹은 coplete 이진트리의 높이는 O(logN) 
  최악의 경우 n이 될 수도 있음
<br/>


**연결구조(Linked structure) 표현**

- 각 노드에 하나의 데이터 필드와 왼쪽 자식, 오른쪽 자식, 부모 노드의 주소를 저장
  (부모 노드의 주소는 반드시 필요한 경우가 아니면 보통 생략)
- 루트 노드의 주소는 따로 보관
<br/>


**이진트리의 순회(traversal)**

- 순회: 이진 트리의 모든 노드를 방문하는 일
- 중순위(inorder) 순회
- 선순위(preorder) 순회
- 후순위(postorder) 순회
- 레벨오더(level-order) 순회
<br/>


(루튼노드 r, 왼쪽 부트리 TL, 오른쪽 부트리 TR)

**inorder 순회**

TL을 inorder로 순회 - r을 순회 - TR을 inorder로 순회

시간복잡도 O(n)

**preorder 순회**

r을 순회 - TL을 preorder로 순회 - TR을 preorder로 순회

**postorder 순회**

TL을 postorder로 순회 - TR을 postorder로 순회 - r을 순회

**level-order 순회**

- 레벨 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로
- queue를 이용하여 구현

<br/><br/>



### 이진검색트리 (Binary Search Tree)

Danamic Set: 데이터들이 고정되어 있지 않고 계속해서 변함

- 여러개의 key를 저장
- 다음과 같은 연산들을 지원하는 자료구조
  INSERT(새로운 키 삽입), SEARCH(키 탐색), DELETE(키 삭제)

|            |       | search  | inset      | delete |
| ---------- | ----- | ------- | ---------- | ------ |
| 배열       | 정렬  | O(logn) | O(n)       | O(n)   |
|            | 정렬x | O(n)    | O(1), O(n) | O(1)   |
| 연결리스트 | 정렬  | O(n)    | O(n)       | O(1)   |
|            | 정렬x | O(n)    | O(1)       | O(1)   |

- 정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)

<br/>

**검색트리**

- Danamic Set을 트리의 형태로 구현
- 일반적으로 INSERT, SEARCH, DELETE 연산이 트리의 높이에 비례하는 시간복잡도를 가짐
- 이진검색트리, 레드-블랙 트리, B-트리 등

<br/>

**이진검색트리(BST)**

- 이진트리
- 각 노드에 하나의 키를 저장
- 각 노드 v에 대해서 그 노부의 왼쪽 부트리에 있는 키들은 key[v] (v에 저장된 key)보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같음
- 각종 연산의 시간복잡도 O(h)
- 최악의 경우 트리의 높이 h=O(h)
- 균형잡힌(balanced) 트리
  - 레드-블랙 트리 등
  - 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(logn)으로 유지

<br/>

**search** 

- 시간복잡도 O(h), h는 트리의 높이

- 최소값은 항상 가장 왼쪽 노드에 존재
- 최대값은 항상 가장 오른쪽 노드에 존재
- successor: 노드 x의 successor란 key[x] 보다 크면서 가장 작은 키를 가진 노드(모든 키들이 서로 다르다고 가정)
  세가지 경우
  - 노드 x의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최소값
  - 오른쪽 부트리가 없는 경우, 어떤 노드 y의 왼쪽 부트리의 최대값이 x가 되는 그런 노드 y가 x의 successor
  - 그런 노드 y가 존재하지 않을 경우 successor가 존재하지 않음(즉, x가 최대값)
- predecessor: 노드 x의 predecessor란 key[x]보다 작으면서 가장 큰 키를 가진 노드, successor와 반대

<br/>

**insert**

- 기존에 있는 노드들을 건드리지 않음
- 2개의 포인터 x, y를 사용
- 시간복잡도: O(h)


<br/>

**delete**

- 사전작업으로 search 포함
- case 1: 자식노드가 없는 경우 -> 그냥 삭제(부모노드의 필드를 null로 바꿔줌)
  시간복잡도: O(1)
- case 2: 자식노드가 1개인 경우 -> 자신의 자식노드를 원래 자신의 위치로
  시간복잡도: O(1)
- case 3: 자식노드가 2개인 경우 -> 노드는 그대로 두고 데이터를 삭제하고 삭제하려는 노드의 successor의 데이터를 옮겨옴
  successor는 왼쪽 자식이 없음. 자식의 개수가 0아니면 1 -> case1, case2에 해당
  시간복잡도: O(h)


<br/><br/>


### 레드블랙트리 (Red-Black Tree)

- 이진탐색트리의 일종
- 균형잡힌 트리: 높이가 O(log2n)
- SEARCH, INSERT, DELETE 연산을 최악의 경우에도 O(log2n) 시간에 지원
- 각 노드는 하나의 키, 왼쪽 자식(left), 오른쪽 자식(right) 그리고 부모노드(p)의 주소를 저장
- 자식노드가 존재하지 않을 경우 NIL노드라고 부르는 특수한 노드가 있다고 가정
- 따라서 모든 리프노드는 NIL노드
- 루트의  부모도 NIL노드라고 가정
- 노드들은 내부노드와 NIL노드로 분류

<br/>

**정의**

1. 각 노드는 red 혹은 black
2. 루트노드는 black
3. 모든 리프노드(즉, NIL노드)는 black
4. red노드의 자식노드들은 전부 black(즉, red 노드는 연속되어 등장하지 않음)
5. 모든 노드에 대해서 그 노드로부터 자손인 리프노드에 이르는 모든 경로에는 동일한 개수의 black노드가 존재

<br/>

**레드-블랙 트리의 높이**

- 노드 x의 높이 h(x)는 자신으로부터 리프노드까지의 가장 긴 경로에 포함된 에지의 개수
- 노드 x의 블랙-높이 bh(x)는 x로부터 리프노드까지의 경로상의 블랙노드의 개수(노드 x 자신은 불포함)
- 높이가 h인 노드의 블랙-높이는 bh >= h/2
  레드노드는 연속될 수 없으므로
- 노드 x를 루트로하는 임의의 부트리는 적어도 2^bh(x) - 1개의 내부노드를 포함(수학적 귀납법)
- n개의 내부노드를 가지는 레드블랙트리의 높이는 2log2(n+1)이하


<br/><br/><br/>

출처: 인프런 - 영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠 교수님)
