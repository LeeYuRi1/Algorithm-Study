### 그래프 (Graph)

- **(무방향) 그래프** 
  - G = (V, E)
  - V = 노드(node) 혹은 정점(vertex)
  - E = 노드쌍을 연결하는 에지(edge) 혹은 링크(link)
  - 개체들 간의 이진관계를 표현
  - n = |V|, m = |E| (n은 정점의 개수, m은 에지의 개수)

<br/>

- **방향그래프(Directed Graph)** 
  - G = (V, E)
  - edge(u, v)는 u로부터 v로의 방향을 가짐
  - (u, v) != (v, u)
  - 화살표로 표시

<br/>

- **가중치(weighted) 그래프**
  - edge마다 가중치가 지정

<br/><br/>

### **그래프의 표현**

- **인접행렬(adjacency matrix)**

  ![1604917114431](https://user-images.githubusercontent.com/33548856/102020923-aa4aaa80-3dbf-11eb-8ef0-7e4ce4027642.png)

  - i 와 j 사이에 edge가 있으면 i행 j열의 값이 1, 없으면 0
  - 저장 공간 크기: O(n^2)
  - 어떤 노드 v에 인접한 모든 노드 찾기: O(n) 시간
  - 어떤 에지 (u, v)가 존재하는지 검사: O(1) 시간

  <br/>

- **인접리스트(adjacency list)**

  - 정점 집합을 표현하는 하나의 배열과 각 정점마다 인접한 정점들의 연결 리스트

    ![1604917599715](https://user-images.githubusercontent.com/33548856/102020942-c2bac500-3dbf-11eb-8996-8b72e1938615.png)

  - 노드의 개수: 2m (m: edge의 개수)

  - 저장 공간 크기: O(n+m)

  - 어떤 노드 v에 인접한 모든 노드 찾기: O(degree(v)) 시간
    (degree(v): 노드v의 인접한 노드의 개수)
연결리스트의 길이에 비례, 인접행렬보다 유리
    
  - 어떤 에지 (u, v)가 존재하는지 검사: O(degree(u)) 시간
    
    
    연결리스트의 길이에 비례, 인접행렬보다 불리

<br/>

- **방향그래프**
  - 인접행렬은 비대칭
  - 인접 리스트는 m개의 노드를 가짐

<br/>

- **가중치 그래프의 인접행렬 표현**
  - edge의 존재를 나타내는 값으로 1대신 edge의 가중치를 저장
  - edge가 없을 때 혹은 대각선일 때
    - 특별히 정해진 규칙은 없으며, 그래프와 가중치가 의미하는 바에 따라 결정
    - 예: 가중치가 거리 혹은 비용을 의미하는 경우라면 edge가 없으먄 무한대, 대각선은 0
    - 예: 만약 가중치가 용량을 의미한다면 edge가 없을 때 0, 대각선은 무한대

<br/>

- **경로와 연결성**
  - 무방향 그래프 G = (V, E)에서 노드 u와 노드 v를 연결하는 경로(path)가 존재할 때 v와 u는 서로 연결되어 있다고 말함
    직접 연결되어 있으면 -> 인접, edge들을 거쳐서 갈 수 있으면 -> 연결되어 있다.
  - 모든 노드 쌍들이 서로 연결된 그래프를 연결된(connected) 그래프라고 함
  - 연결요소(connected component): 연결 되어있는 것들을 각각 말함

<br/><br/>



### 그래프 순회 (Graph Traversal)

- 순회: 그래프의 모든 노드들을 방문하는 일
- 대표적 두 가지 방법
  - BFS(Breadth-First Search, 너비우선순회)
  - DFS(Depth-First Search, 깊이우선순회)

<br/>

### 너비우선순회(BFS)

![1607965824355](C:\Users\LEE\AppData\Roaming\Typora\typora-user-images\1607965824355.png)

- **동심원 형태로 순회**

- 다음 순서로 노드들을 방문

  - L0 = {s}, s는 출발 노드
  - L1 = L0의 모든 이웃 노드들(직접 에지로 연결된 노드들)
  - L2 = L1의 이웃을 중 L0에 속하지 않는 노드들
  - Li = Li-1의 이웃들 중 Li-2에 속하지 않는 노드들

  <br/>

- **큐를 이용**

  1. 출발 노드를 표시함 (체크는 이미 방문된 노드라는 표시)

  2. 출발 노드를 큐에 넣음

  3. queue가 empty가 아닌동안 while문을 돌면서 
     큐에서 노드를 하나 꺼내고(맨 앞 노드), 큐에서 꺼낸 노드의 아직 방문되지 않은(unchecked) 모든 이웃 노드들(w)을 체크하고 큐에 넣음

     <br/>

- **BFS와 최단 경로**
  - s에서 Li에 속한 노드까지의 최단 경로의 길이는 i (경로의 길이는 경로에 속한 에지의 개수를 의미)
  - BFS를 하면서 각 노드에 대해서 최단 경로의 길이를 구할 수 있음
  - 입력: 방향 혹은 무방향 그래프 G=(V,E), 그리고 출발 노드 s (V에 포함)
  - 출력: 모든 노드 v에 대해서
    - d[v] = s로부터 v까지의 최단 경로의 길이(에지의 개수)
    - π[v] = s로부터 v까지의 최단경로상에서 v의 직전 노드(predecessor)
  - 인접행렬로 구현할 경우 시간복잡도는 O(n^2)
    인접리스트로 구현할 경우 시간복잡도는 O(n+m)

<br/>

- **BFS 트리**
  ![1607965877562](C:\Users\LEE\AppData\Roaming\Typora\typora-user-images\1607965877562.png)
  - 각 노드 v와 π[v]를 연결하는 에지들로 구성된 트리
  - BFS 트리에서 s에서 v까지의 경로는 s에서 v까지 가는 최단경로
  - 어떤 에지도 2개의 layer를 건너가지 않음(동일 레이어의 노드를 연결하거나, 혹은 1개의 layer를 건너감)

<br/>

- 그래프가 disconnected이거나 혹은 방향 그래프라면 BFS에 의해서 모든 노드가 방문되지 않을 수도 있음
  상관없이 모든 노드를 방문하고 싶다면 BFS를 반복하여 모든 노드 방문



<br/><br/><br/>

출처: 인프런 - 영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠 교수님)
