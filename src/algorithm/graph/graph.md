### 그래프 (Graph)

- **(무방향) 그래프** 
  - G = (V, E)
  - V = 노드(node) 혹은 정점(vertex)
  - E = 노드쌍을 연결하는 에지(edge) 혹은 링크(link)
  - 개체들 간의 이진관계를 표현
  - n = |V|, m = |E| (n은 정점의 개수, m은 에지의 개수)

<br/>

- **방향그래프(Directed Graph)** 
  - G = (V, E)
  - edge(u, v)는 u로부터 v로의 방향을 가짐
  - (u, v) != (v, u)
  - 화살표로 표시

<br/>

- **가중치(weighted) 그래프**
  - edge마다 가중치가 지정

<br/><br/>

### **그래프의 표현**

- **인접행렬(adjacency matrix)**

  ![1604917114431](https://user-images.githubusercontent.com/33548856/102020923-aa4aaa80-3dbf-11eb-8ef0-7e4ce4027642.png)

  - i 와 j 사이에 edge가 있으면 i행 j열의 값이 1, 없으면 0
  - 저장 공간 크기: O(n^2)
  - 어떤 노드 v에 인접한 모든 노드 찾기: O(n) 시간
  - 어떤 에지 (u, v)가 존재하는지 검사: O(1) 시간

  <br/>

- **인접리스트(adjacency list)**

  - 정점 집합을 표현하는 하나의 배열과 각 정점마다 인접한 정점들의 연결 리스트

    ![1604917599715](https://user-images.githubusercontent.com/33548856/102020942-c2bac500-3dbf-11eb-8996-8b72e1938615.png)

  - 노드의 개수: 2m (m: edge의 개수)

  - 저장 공간 크기: O(n+m)

  - 어떤 노드 v에 인접한 모든 노드 찾기: O(degree(v)) 시간
    (degree(v): 노드v의 인접한 노드의 개수)
연결리스트의 길이에 비례, 인접행렬보다 유리
    
  - 어떤 에지 (u, v)가 존재하는지 검사: O(degree(u)) 시간
    
    
    연결리스트의 길이에 비례, 인접행렬보다 불리

<br/>

- **방향그래프**
  - 인접행렬은 비대칭
  - 인접 리스트는 m개의 노드를 가짐

<br/>

- **가중치 그래프의 인접행렬 표현**
  - edge의 존재를 나타내는 값으로 1대신 edge의 가중치를 저장
  - edge가 없을 때 혹은 대각선일 때
    - 특별히 정해진 규칙은 없으며, 그래프와 가중치가 의미하는 바에 따라 결정
    - 예: 가중치가 거리 혹은 비용을 의미하는 경우라면 edge가 없으먄 무한대, 대각선은 0
    - 예: 만약 가중치가 용량을 의미한다면 edge가 없을 때 0, 대각선은 무한대

<br/>

- **경로와 연결성**
  - 무방향 그래프 G = (V, E)에서 노드 u와 노드 v를 연결하는 경로(path)가 존재할 때 v와 u는 서로 연결되어 있다고 말함
    직접 연결되어 있으면 -> 인접, edge들을 거쳐서 갈 수 있으면 -> 연결되어 있다.
  - 모든 노드 쌍들이 서로 연결된 그래프를 연결된(connected) 그래프라고 함
  - 연결요소(connected component): 연결 되어있는 것들을 각각 말함

<br/><br/>



### 그래프 순회 (Graph Traversal)

- 순회: 그래프의 모든 노드들을 방문하는 일
- 대표적 두 가지 방법
  - BFS(Breadth-Firsh Search, 너비우선순회)
  - DFS(Depth-First Search, 깊이우선순회)



<br/><br/><br/>

출처: 인프런 - 영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠 교수님)
