# 수학

</br>

## 나머지 연산

- 컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제 등장(dp에서 주로 나옴)
- 전체 정답을 구하고 나머지를 출력하는 것이 아니라 중간에 정수 범위를 넘어가기 때문에 매번 구하면서 나머지 연산을 해야함
- (A+B) %M = ((A%M) + (B%M)) %M
- (AxB) %M = ((A%M) x (B%M)) %M
- (A-B) %M = ((A%M) - (B%M) + M) %M 뺄셈의 경우 먼저 mod연산을 한 결과가 음수가 나올 수 있기 때문에 이렇게 함(+M)
- 나누기는 성립하지 않음


</br></br>


## 최대공약수

- GCD
- 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수
- 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A, B)까지 모든 정수로 나누어 보는 방법
- 최대공약수가 1인 두 수를 서로소(Coprime)라고 함

```java
// 시간복잡도: O(N)
int g = 1;
for (int i = 2; i < min(a, b); i++) {
	if (a % i == 0 && b % i == 0) {
		g = i;
	}
}

// 유클리드 호제법(재귀 사용)
int gcd(int a, int b) {
	if (b == 0) return a;
	else return gcd(b, a%b);
}
```

- 유클리드 호제법
  - a를 b로 나눈 나머지를 r이라고 함
  - GCD(a, b) = GCD(b, r)
  - r이 0이면 그때 b가 최대공약수
  - GCD(24, 16) = GCD(16, 8) = GCD(8, 0) = 8
- 세 수의 최대공약수
  - GCD(a, b,c) = GCD(GCD(a, b), c)
  - 네 수, N개의 숫자도 위와 같은 식으로 계속해서 구할 수 있음


</br></br>


## 최소공배수

- LCM
- 두 수의 최소공배수는 두 수의 공통된 배수 중에서 가장 작은 정수
- GCD를 응용해서 구할 수 있음
- L * G = A * B -> L = A * B / G
- 두 수 a,b의 최대공약수를 g라고 했을 때
- 최소공배수 l = g * (a/g) * (b/g)


</br></br>


## 진법변환

### 10진법 -> B진법

- 10진법 수 N을 B진법으로 바꾸려면 N이 0이 될 때까지 나머지를 계속해서 구하면 됨
- 11을 3진법으로 나누는 방법
  - 11/3 = 3...2
  - 3/3 = 1...0
  - 1/3 = 0...1
  - 11은 3진법으로 102

</br>

### B진법 -> 10진법

- B진법 수 N을 10진수로 바꾸려면 B^k을 곱하면서 더해가면 됨
- 3진법 수 102 = 1x3^2 + 0x3^1 + 2x3^0 = 11

</br>

### 2진수 -> 8진수

- 10진수로 바꿀 필요 없음
- 2진수에서 3자리씩 묶으면 8진수가 됨

</br>

### 8진수 -> 2진수

- 한자리씩 2진수로 바꿈
- 5 6 3 = 101 110 011

</br>

### -2진수

- 일반적인 진법 변환과 똑같이 변환을 하면 됨
- 나머지가 음수가 나오면 안된다는 점을 조심해서 코딩해야 함
- 2가지 경우로 나눠볼 수 있음
  - 양수/-2
  - 음수/-2
- 각각의 경우에서 양수가 2로 나누어 떨어지는 경우와 음수가 2로 나누어 떨어지는 경우로 나눌 수가 있음
- 6/2 = 3...0 양수 짝수를 2로 나누는 경우
  7/2 = 3...1 양수 홀수를 2로 나누는 경우
  -6/2 = -3...0 음수 짝수를 2로 나누는 경우
  -7/2 = -4...1 음수 홀수를 2로 나누는 경우

</br>

### 진법 변환

- A진법을 B진법으로 바꾸는 방법
- A진법 -> 10진법 -> B진법


</br></br>


## 소수

- 약수가 1과 자신 밖에 없는 수

1. N이 소수가 되려면 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안됨
   - 시간복잡도: O(N)
2. N이 소수가 되려면 2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 떨어지면 안됨
   - 시간복잡도: O(N)
   - 이유: N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문
   - N=a*b로 나타낼 수 있는데, a가 작을수록 b는 큼
   - 가능한 a중에서 가장 작은 값은 2이기 때문에, b는 N/2를 넘지 않음

3. N이 소수가 되려면 2보다 크거나 같고, 루트N보다 작거나 같은 자연수로 나누어 떨어지면 안됨
   -  시간복잡도: O(루트N) 가장 빠른 방법
   - 이유: N이 소수가 아니라면 N=a*b로 나타낼 수 있음(a <= b)
   - a와 b 둘 중 하나는 루트 n보다 같거나 작아야함
   - a와 b의 차이가 가장 작은 경우는 루트 N임
   - a<=b 일때 a는 2부터 루트N까지 될 수 있음, b는 루트N보다 큰 약수가 됨
   - i <= 루트N에서 i는 정수인데 루트N은 실수이기 때문에 오차가 발생할 수 있음. 
     i * i <= n로 사용

```java
boolean prime(int n) {
	if (n < 2) {
        return false;
    }
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
            return false;
        }
	}
	return true;
}
```



- 어떤 수 N이 소수인지 아닌지 알아내는데 걸리는 시간 복잡도는 O(루트N)이었음
- 각각의 수에 대해서 소수인지 검사할 때 각각의 수에 대해 O(루트N)의 시간이 걸림
- 수는 총 N개이기 때문에, O(N루트N)이 걸림 -> 너무 긴 시간 필요

</br>

### 에라토스테네스의 체

- 1부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용

  1. 2부터 N까지 모든 수를 써놓음

  2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾음
  3. 그 수는 소수임
  4. 이제 그 수의 배수를 모두 지움

- 남아있는 모든 수는 소수임!

```java
int n = sc.nextInt();
int m = sc.nextInt();
boolean check[] = new boolean[m + 1];
check[0] = check[1] = true;
for (int i = 2; i * i <= m; i++) {
	if (!check[i]) {
		for (int j = i + i; j <= m; j += i) {
			check[j] = true;
		}
	}
}
```

</br></br>



## 소인수분해

- 정수 N을 소수의 곱으로 분해
- 소수를 구하지 않고도 해결할 수 있음
- N을 소인수분해 했을 때, 나타날 수 있는 인수 중에서 가장 큰 값은 루트N
- 따라서, 2부터 루트 N까지 for문을 돌면서 N을 나눌 수 있으면, 나눌 수 없을 때까지 계속해서 나누면 됨

```java
for (int i=2; i*i <= n; i++) {
	while (n % i == 0) {
		System.out.println(i);
		n /= i;
	}
}
//어떤 수가 루트n보다 큰 수는 하나밖에 없으므로 if문 하나로 판단
if (n > 1) {
	System.out.println(n);
}
```

</br></br>



## 팩토리얼

- 팩토리얼은 매우 큰 값
- N! = 1 * 2 * ... * N
- 6! = 720, 8! = 40320, 10! = 3628800

```java
int n = sc.nextInt();
int answer = 1;
for (int i = 2; i <= n; i++) {
	answer *= i;
}
System.out.println(answer);
```

</br>

- 팩토리얼 0의 개수

  - 10 = 2 * 5이므로 소인수분해 해서 2와 5가 몇제곱인지 알면 10이 몇개 나오는지 알 수 있음
  - 2의 제곱이 5의 제곱보다 훨씬 많기 때문에 5^k의 k가 0의 개수와 같음

  ```java
  int n = sc.nextInt();
  int answer = 0;
  for (int i = 5; i <= n; i *= 5){
      answer += n / i;
  }
  System.out.println(answer);
  ```

  </br></br>



## 조합

- nCm = n! / m!(n-m)!
- 0의 개수를 구하는 문제
  - 팩토리얼은 2의 개수가 5의 개수보다 항상 많기 때문에 5의 개수만 세어줌
  - 조합은 어떻게 될 지 모르기 때문에 2의 개수와 5의 개수를 동시에 세어줘야함

</br></br>



[출저: code.plus]
