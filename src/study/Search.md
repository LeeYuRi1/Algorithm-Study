# 탐색

</br>

## 이분 탐색 (Binary Search)

- 정렬되어 있는 리스트에서 어떤 값을 빠르게 찾는 알고리즘
- 리스트의 크기를 N이라고 했을 때 logN의 시간이 걸림

```java
while (left <= right) {
	int mid = (left + right) / 2; 
    //오버플로우 날 수 있기 때문에 left + (right - left) / 2;로 쓸 수 있음
	if (a[min] == x) {
		position = mid;
		break;
	} else if (a[mid] > x) {
		right = mid - 1;
	} else {
		left = mid + 1;
	}
}
```

</br>

</br>

## 이분탐색으로 정답 찾기

- 정답을 구하는 것은 어렵지만 X가 가능한지 아닌지를 알아내는 것은 쉬운 문제들이 있음

- 정답을 구하는 문제 (최적화)
  - A에서 B까지 가는 가장 빠른 시간을 구하는 것
- 가능한지 살펴보는 문제 (Yes/No)
  - A에서 B까지 X라는 시간으로 이동할 수 있나?

- 정답을 구하는 문제를 가능여부를 판별하는 문제로 바꿀 수 있음
  - A에서 B까지 가는 가장 빠른 시간이 M인 경우에 
    - M보다 빠른 시간은 모두 불가능
    - M보다 큰 시간은 모두 가능
- 가능한지 아닌지를 알아보는 문제도 정답을 구하는 문제로 바꿀 수 있음

- 어떤 기준 X를 가지고 Yes/No로 나누어지는 것만 정답을 찾을 수 있음
  - No -> Yes가 되는 기준은 최소값
  - Yes -> No가 되는 기준은 최대값
  - Yes와 No가 왔다갔다하면 정답을 찾을 수 없음

</br>

</br>

## 완전 탐색 - 비트마스크

### 비트 연산

- 비트(bit) 연산을 사용해서 부분 집합을 표현할 수 있음

| A    | B    | ~A   | A&B  | A\|B | A^B  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 1    | 0    | 0    | 0    |
| 0    | 1    | 1    | 0    | 1    | 1    |
| 1    | 0    | 0    | 0    | 1    | 1    |
| 1    | 1    | 0    | 1    | 1    | 0    |

- ~(not): 0이면 1, 1이면 0
- &(and) : 둘 다 1일 때 1
- |(or) : 둘 다 0이 아닐 때 1 (하나라도 1이면 1)

- ^(xor) : 다르면 1, 같으면 0

</br>

- 두 수 A와 B를 비트 연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 됨

- not연산의 경우에는 자료형에 따라 결과가 달라짐
  - 앞에 0이 있기 때문. 0의 개수가 자료형에 따라 다름
- signed, unsigned에 따라 보여지는 값이 다름
  - signed: 부호를 가지는 값(양수, 음수 구별)
  - unsigned: 부호를 가지지 않는 값(오직 양수)

</br>

- shift 연산
  - shift left(<<)와 shift right(>>) 연산이 있음
  - A << B: A를 왼쪽으로 B비트만큼 민다 (A x 2^B과 같음)
  - A >> B: A를 오른쪽으로 B비트만큼 민다 (A / 2^B과 같음)
  - (A+B) / 2는 (A+B) >> 1로 쓸 수 있음
  - 어떤 수가 홀수인지 판별하는 if(N%2 == 1)은 if(N&1)로 줄여 쓸 수 있음

</br>

- 정수로 집합을 나타낼 수 있음
  - {1, 3, 4, 5, 9} = 570 = 2^1 + 2^3 + 2^4 + 2^5 + 2^9 (1000111010)
  - 길이가 n인 이진수로 0~n-1까지 숫자의 부분 집합을 나타낼 수 있음

- 어떤 수가 포함되어 있는지 검사: &(and)연산 이용
  - x번째 비트만 1: s & (1 << x) 
  - 0이 포함되어 있는지 검사하려면 0번째 비트를 1로 만들고 and 연산을 함
    570 & 2^0 = 570 & (1<<0) = 0

- 추가하는 연산: |(or)연산 이용
  - 2 추가하기: 570 | 2^2 = 570 | (1<<2) = 574 (1000111110)
  - 중복 영향 없음 1과 1을 or하면 1임

- 제거하는 연산: ~(not)연산 이용
  - x번째 비트만 0으로 만들고 and 연산
  - 2 제거하기:  570 & ~2^2 = 570 & ~(1<<2) = 570 (1000111010)
- 전체 집합
  - (1 << n) -1 
  - 2^n -1

- 공집합
  - 0

</br>

### 정리

현재 집합이 S일 때

- i를 추가: S | (1 << i)
- i를 검사: S & (1 << i)
- i를 제거: S & ~(1 << i)
- i를 토글(0을 1로, 1을 0으로): S ^ (1 << i)

</br>

- 물론 배열을 사용하는 것이 더욱 편리하지만, 비트마스크를 사용하는 이유는 집합을 배열의 인덱스로 표현할 수 있기 때문
- 상태 다이나믹을 할 때 자주 사용
